<script type="text/javascript">
  (() => {
    const loadPreviews = async function() {
      const containerList = Array.from(document.getElementsByClassName("ts-chat-container"));
      containerList.forEach(container => {
        const files = Array.from(container.getElementsByClassName("ts-chat-message-attachment-file"));
        // filter files for correct button
        const messages = Array.from(document.getElementsByClassName("ts-chat-message-content ts-parsed-text-content"))
          .filter(elem => elem.children.length == 1 && elem.firstElementChild.children.length == 1 && elem.children[0].tagName == "A");
        for (message of messages) {
          if (message.firstElementChild.firstElementChild.tagName != "SPAN") continue;
          const link = message.firstElementChild.href;
          if (link.endsWith(".jpg") || link.endsWith(".jpeg") || link.endsWith(".png") || link.endsWith(".gif")) {
            message.firstElementChild.innerHTML = `<img src="${link}" style="max-width: 350px; max-height: 350px;" />`;
          }
          if (link.endsWith(".webm")) {
            message.firstElementChild.innerHTML = `<video controls loop style="max-width: 350px; max-height: 350px;"><source src="${link}" type="video/webm"></video>`;
          }
          if (link.endsWith(".mp4")) {
            message.firstElementChild.innerHTML += `<p style="font-size: .7em; padding-top: 1em;"><i>TeamSpeak does not support MP4s.</i></p>`;
          }
        }
      });
    }

    const replacementCallback = async function() {
      loadPreviews();
    }
    
    //poll each .5 sec for open chat windows
    var a = [];
    setInterval(async () => {
      containerList = Array.from(document.getElementsByClassName("ts-chat-container"));
      var tmpList = [];
      await Promise.all(containerList.map((container) => {
        const actualContainer = container.getElementsByClassName("tsv-virtual-list-container")[0]
        const replacementObserver = new MutationObserver(replacementCallback);
        if (a.map(obj => obj.key).includes(actualContainer)) return;
        replacementObserver.observe(actualContainer, {childList: true, subtree: true});
        tmpList.push({key: actualContainer, value: replacementObserver});
        loadPreviews();
      }));
      // disconnect all observers that are not in the new list
      a.forEach(obj => {
        if (!tmpList.map(iobj => iobj.key).includes(obj.key)) {
          obj.value.disconnect();
        }
      });
      a = tmpList;
    }, 500);
  })()
</script>