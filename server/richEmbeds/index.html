<script type="text/javascript">
  (() => {
    const maxImageWidth = 350;
    const maxImageHeight = 500;
    const maxVideoWidth = 350;
    const maxVideoHeight = 500;
    
    const debounce = function(func, timeout = 300) {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => { func.apply(this, args); }, timeout);
      };
    }

    const loadTweets = debounce(() => twttr.widgets.load());

    const loadPreviewInContainer = async function(messageWrapper) {
      const messages = Array.from(messageWrapper.getElementsByClassName("ts-chat-message-content ts-parsed-text-content"))
        .filter(elem => elem.children.length == 1 && elem.firstElementChild.children.length == 1 && elem.children[0].tagName == "A");
      for (message of messages) {
        if (message.firstElementChild.firstElementChild.tagName != "SPAN") continue;
        const link = message.firstElementChild.href;
        
        // parse link to get file extension without parameters
        const extension = link.split(".").pop().split("?")[0];
        // get hostname without www
        const hostname = link.split("//")[1].split("/")[0];

        if (["jpg", "jpeg", "png", "gif"].includes(extension)) {
          message.firstElementChild.innerHTML = `<img src="${link}" style="max-width: ${maxImageWidth}px; max-height: ${maxImageHeight}px;" />`;
        }
        else if (["webm"].includes(extension)) {
          message.firstElementChild.innerHTML = `<video controls loop style="max-width: ${maxVideoWidth}px; max-height: ${maxVideoHeight}px;"><source src="${link}" type="video/webm"></video>`;
        }
        else if (["mp4", "avi", "mkv"].includes(extension)) {
          message.firstElementChild.innerHTML += `<p style="font-size: .7em; padding-top: 1em;"><i>TeamSpeak doesn not support this video format.</i></p>`;
        }
        else if (hostname == "twitter.com") {
          // embed tweet
          const tweet = await fetch(`https://publish.twitter.com/oembed?theme=dark&dnt=true&omit_script=true&url=${link}`);
          const tweetJson = await tweet.json();
          message.innerHTML = tweetJson.html;
          message.style.whiteSpace = "initial";
          loadTweets();
        }
      }
    }

    const loadPreviews = async function() {
      const containerList = Array.from(document.getElementsByClassName("ts-chat-container"));
      containerList.forEach(container => {
        loadPreviewInContainer(container);
      });
    }

    const replacementCallback = function(mutationsList, observer) {
      something = mutationsList;
      for(const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          for (const node of mutation.addedNodes) {
            // TODO can this be handled better?
            if (node.nodeName == "DIV" && !node.classList.contains("rich-embed")) {
              loadPreviewInContainer(node);
              node.classList.add("rich-embed");
            }
          }
        }
      }
    }
    
    var something = undefined;
    //poll each .5 sec for open chat windows
    var a = [];
    setInterval(async () => {
      containerList = Array.from(document.getElementsByClassName("ts-chat-container"));
      var tmpList = [];
      await Promise.all(containerList.map((container) => {
        const actualContainer = container.getElementsByClassName("tsv-virtual-list-container")[0]
        if (a.map(obj => obj.key).includes(actualContainer)) {
          tmpList.push({key: actualContainer, value: a.filter(obj => obj.key == actualContainer)[0].value});
          return;
        }
        const replacementObserver = new MutationObserver(replacementCallback);
        replacementObserver.observe(actualContainer, {childList: true, subtree: true});
        tmpList.push({key: actualContainer, value: replacementObserver});
        loadPreviews();
      }));
      // disconnect all observers that are not in the new list
      a.forEach(obj => {
        if (!tmpList.map(iobj => iobj.key).includes(obj.key)) {
          obj.value.disconnect();
        }
      });
      a = tmpList;
    }, 500);
  })()
</script>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>